#pragma once
#include "TreapNode.h"

/*
 * @brief Представляет структуру трепа.
 *
 * Эта структура содержит указатель на корень трепа.
 */
struct Treap
{
    ///< Указатель на корневой узел трепа.
    TreapNode* Root;
};

/*
 * @brief Создает новый треп.
 *
 * Эта функция выделяет память для нового трепа и инициализирует его корень как nullptr.
 *
 * @return Указатель на только что созданный треп.
 */
Treap* CreateTreap();

/*
 * @brief Делит треп на две части по заданному ключу.
 *
 * Эта функция делит треп на два под-трепа: один содержит узлы с ключами меньше или равными
 * указанному ключу, а другой содержит узлы с ключами больше этого ключа.
 *
 * @param node Указатель на корень трепа, который нужно разделить.
 * @param key Ключ, по которому нужно разделить треп.
 * @param left Ссылка на указатель, где будет храниться левая часть трепа.
 * @param right Ссылка на указатель, где будет храниться правая часть трепа.
 */
void Split(TreapNode* treap, int key, TreapNode*& left, TreapNode*& right);

/*
 * @brief Объединяет два трепа в один.
 *
 * Эта функция комбинирует два под-трепа в один, сохраняя свойства кучи и бинарного поиска.
 *
 * @param left Указатель на первый треп (левая часть).
 * @param right Указатель на второй треп (правая часть).
 * @return Указатель на корень объединенного трепа.
 */
TreapNode* Merge(TreapNode* left, TreapNode* right);

/*
 * @brief Вставляет ключ в треп без оптимального балансирования.
 *
 * Эта функция добавляет новый ключ в треп, не обеспечивая при этом поддержание оптимальных свойств кучи
 * после вставки. Это может привести к неустойчивому состоянию со временем, если использовать повторно без операций балансировки.
 *
 * @param treap указатель, где будет обновлен корень трепа после вставки.
 * @param key Ключ, который нужно вставить в треп.
 */
Treap* InsertUnoptimized(Treap* treap, int key);

/*
 * @brief Вставляет ключ в треп с поддержанием оптимального баланса.
 *
 * Эта функция добавляет новый ключ в треп и обеспечивает поддержание свойств кучи после вставки,
 * потенциально вращая узлы по мере необходимости.
 *
 * @param root Ссылка на указатель, где будет обновлен корень трепа после вставки.
 * @param key Ключ, который нужно вставить в треп.
 */
Treap* InsertOptimized(Treap* treap, int key);

/*
 * @brief Удаляет ключ из трепа без оптимального балансирования.
 *
 * Эта функция удаляет указанный ключ из трепа, не обеспечивая при этом поддержание оптимальных свойств кучи
 * после удаления.
 *
 * @param Treap Ссылка на указатель, где будет обновлен корень трепа после операции удаления.
 * @param key Ключ, который нужно удалить из трепа.
 */
Treap* RemoveUnoptimized(Treap* treap, int key);

/*
 * @brief Удаляет ключ из трепа с поддержанием оптимального баланса.
 *
 * Эта функция удаляет указанный ключ из трепа и обеспечивает поддержание свойств кучи после удаления,
 * потенциально вращая узлы по мере необходимости.
 *
 * @param node Ссылка на указатель, где будет обновлен корень трепа после операции удаления.
 * @param key Ключ, который нужно удалить из трепа.
 */
Treap* RemoveOptimized(Treap* treap, int key);

/*
 * @brief Ищет ключ в трепе.
 *
 * Эта функция рекурсивно ищет указанный ключ в трепе и возвращает
 * соответствующий узел, если он найден.
 *
 * @param node Указатель на текущий узел в трепе.
 * @param key Ключ для поиска.
 * @return Указатель на найденный узел или nullptr, если не найден.
 */
TreapNode* Search(Treap* treap, int key);

/*
 * @brief Очищает все узлы в трепе.
 *
 * Эта функция рекурсивно освобождает память для всех узлов в трепе.
 *
 * @param node Ссылка на указатель, где будет очищен корень трепа.
 */
void Clear(TreapNode*& node);

/*
 * @brief Очищает треп.
 *
 * Эта функция рекурсивно освобождает память для всех узлов в трепе.
 *
 * @param reference Ссылка на указатель, где будет очищен корень трепа.
 */
void ClearTreap(Treap*& treap);
